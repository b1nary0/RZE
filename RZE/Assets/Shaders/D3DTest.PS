#pragma pack_matrix( row_major )

struct PS_IN
{
	float4 Position : SV_POSITION;
	float3 Normal : NORMAL;
	float2 Color : UV;
	float3 Tangent : TANGENT;
	float3 FragPos : POSITION;
};

Texture2D textures[3] : register(t0);

SamplerState s1 : register(s0);

struct LIGHT_INPUT_DESC
{
	float4 Position;
	float4 Color;
	matrix LightSpaceMat;
	float Strength;
};

struct CAMERA_INPUT_DESC
{
	float3 Position;
};

struct MATERIAL_DATA
{
	float Shininess;
};

cbuffer LightConstantBuffer : register(b0, space1)
{
	LIGHT_INPUT_DESC lightDesc;
};

cbuffer CameraRootConstant : register(b0, space2)
{
	CAMERA_INPUT_DESC cameraDesc;
};

cbuffer MaterialData : register(b0, space3)
{
	MATERIAL_DATA materialData;
};

float CalculateBlinnPhong(float3 viewDir, float3 lightDir, float3 normal)
{
	float specular = 0.0f;
	
	float3 halfDir = normalize(lightDir + viewDir);
	float specAngle = max(0.0f, dot(halfDir, reflect(-lightDir, normal)));
	specular = pow(specAngle, materialData.Shininess);
	
	return specular;
}

float3 CalculateBumpNormal(float3 inNormal, float3 inTangent, float3 inBumpMapSample)
{
	float3 tangent = normalize(inTangent - dot(inTangent, inNormal) * inNormal);
	float3 biTangent = cross(inTangent, inNormal);
	float3 bumpMapNormal = 2.0f * inBumpMapSample - float3(1.0f, 1.0f, 1.0f);
	
	float3x3 TBN = float3x3(tangent, biTangent, inNormal);
	float3 newNormal = normalize(mul(TBN, bumpMapNormal));
	
	return newNormal;
}

float4 PSMain(PS_IN input) : SV_TARGET
{
	float ambientCoeff = 0.25f;
	
	float4 diffSample = textures[0].Sample(s1, input.Color);
	float4 specularSample = textures[1].Sample(s1, input.Color);
	float4 bumpSample = textures[2].Sample(s1, input.Color);
	
	float3 normal = CalculateBumpNormal(input.Normal, input.Tangent, bumpSample);//normalize(input.Normal.rgb);
	
	float3 lightDir = normalize(lightDesc.Position - input.FragPos).xyz;
	float3 viewDir = normalize(cameraDesc.Position - input.FragPos).xyz;
	
	float diff = max(0.0f, dot(normal, lightDir));
	float specular = CalculateBlinnPhong(viewDir, lightDir, normal);
	
	float3 ambientResult = ambientCoeff * diffSample.rgb;
	float3 diffuseResult = (diffSample.rgb * lightDesc.Color.rgb * lightDesc.Strength * diff);
	float3 specularResult = specular * specularSample.rgb * lightDesc.Strength * lightDesc.Color.rgb;
	
	float3 result = ambientResult + diffuseResult + specularResult;
	
    return float4(result, 1.0f);
}